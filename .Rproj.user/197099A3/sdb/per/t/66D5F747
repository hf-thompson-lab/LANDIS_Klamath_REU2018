{
    "collab_server" : "",
    "contents" : "\n# equilibrium index of list with tolerance for equality #modified from https://www.geeksforgeeks.org/equilibrium-index-of-an-array/ \nequalibrium <- function(arr, tol) {\n  sum <- 0 #initialize sum of whole array\n  leftsum <- 0 # initialize leftsum\n  n<- length(arr)\n  sum <- sum(arr)\n  \n  for (i  in 1:(n-1)) {\n    sum <- sum - arr[i]# // sum is now right sum for index i\n    #print(sum)\n    if (leftsum <= (sum+tol) & leftsum >= (sum-tol))\n      return( i)\n    \n    leftsum <- leftsum + arr[i]\n  }\n  # /* If no equilibrium index found with in the tolerance, then return 0 */ \n  return(-1) # i dont know if this can ever happen with how I call it in findfuelbreaks. \n}\n\n# find connected components of fuelTypes that can be spilt into 4's  \n# @param fuelRaster      - is the fuelType raster from Dyanmic Fire and Fuels Landis-II extension \n    #this works better if you fill the areas of the fuelRaster that you don't want fuel breaks with 0\n# @param fuelValsToConsider - index of fuelVal +1 that you want to cut breaks for\n# @param minCellsConnect - is the smallest cells connected you want to search for\n# @param numFuelsToSplit - is the number of the largest connected components that you want to split in 4's \n# @param numOfLargestFuelsToPickFrom - is the number of the largest connected components that you want to split in 4's that you want to randomly sample from to split\n# @param tabuList - if TRUE, implement the createTabuList function\nfindFuelBreaks <- function(fuelRaster, fuelValsToConsider= (c(1:6,10,11)+1), minCellsConnect , numFuelsToSplit, numOfLargestFuelsToPickFrom, tabuList=T, rownum=310, colnum=312,tabuListPath=tabuListPath){\n  require(raster)\n  require(spatstat)\n  \n  tR1<-fuelRaster\n  values(tR1)[which(values(tR1) >0)] <- -1 \n  \n  # take the fuels that are connected to minCellsConnect or more for each fuel type and tag them with a unique label... \n  for (fuelVal in fuelValsToConsider){\n    \n    tR <- fuelRaster\n    print(fuelVal)\n    \n    destroys <- which(values(tR != fuelVal))\n    if(length(destroys)>= length(values(fuelRaster))-minCellsConnect)\n    {\n      print(\"bad -- too few fuels in fuel type. \")\n      next() \n    }\n    values(tR)[destroys] <- 0  \n    \n    # convert to image object to use the connected function from spatstat library\n    imageF <- im(matrix(values(tR), rownum, colnum)) #the dimesion are flipped from what the raster dims are \n    ci <- connected(imageF, method= \"C\",background = 0) # get the connected components for that fuelVal\n    values(tR) <- as.integer(ci$v) #convert the image back to a raster matrix format\n    \n    # get the largest occuring connected components that are with minCellsConnect and 12000\n    fq <-as.data.frame( freq(tR)) \n    nfq<-na.omit(subset(fq,(fq$count>minCellsConnect & fq$count< (rownum*colnum)/5)  )) # if connect components are too large then the fuel breaks would be too long\n    nfq<- nfq[order(-nfq$count),]\n    if (length(nfq$value) == 0) {print(\"empty nfq - no connected components\"); next()}\n    nfq<- cbind(nfq, rank=length(nfq$value):1 )\n    \n    # TODO - print(nfq) #probably want to log these----\n    \n    temp <- values(tR) \n    \n    # changes the values that connected() returns to the respective rank\n    mapper <- function (x){ y<-nfq$rank[which(nfq$value== x)];  if(length(y) == 0){return(NA) }else{return(y)}} #which returns integer(0) on not found, we need NA \n    temp2 <- sapply(temp, mapper)\n    \n    # combine the connected components to be on a single raster with a unique label \n    replace<-!is.na(temp2)\n    values(tR1)[replace]<- temp2[replace]*(10^ (fuelVal-1)) \n  }\n  \n  temp <- values(tR1)\n  values(tR1)[which(temp==-1 | temp==0)] <-NA #switch the background and out of bounds cells to be NA. \n  \n  # get the largest connected components that we want to split up with fuel breaks \n  newfq <- data.frame(freq(tR1))\n  newerfq<- na.omit(newfq[order(-newfq$count),])\n  \n  if (length(newerfq$value) < numOfLargestFuelsToPickFrom) {numOfLargestFuelsToPickFrom <- length(newerfq$value)}\n  if (length(newerfq$value) < numFuelsToSplit) {numFuelsToSplit <- length(newerfq$value)}\n  toDivide <- head(newerfq, n=numOfLargestFuelsToPickFrom)\n  print(toDivide)\n  print(paste(\"sampling \", numFuelsToSplit,\" from this list\"))\n  toDivide <- toDivide[sample(1:numOfLargestFuelsToPickFrom, numFuelsToSplit),]  # randomized the fuel beaks that we avoid cutting the same thing over and over\n\n  # set up for the spliting (changing NA values and outOfBounds values)\n  emptyR<-fuelRaster\n  values(emptyR)[which(values(emptyR) >0)] <- -1 \n  values(emptyR)[which(values(emptyR) ==-1)] <- 0\n\n  #df to storage data about the splits in (used to see if it was working properly)\n  storage <- data.frame(colEq=numeric(numFuelsToSplit), rowEq=numeric(numFuelsToSplit), step=numeric(numFuelsToSplit))\n  \n  #holder stores the cuts, holder1 stores the large connected components (where if there is a conflict on cell the larger are the ones overwrite) \n  holder <- emptyR\n  holder2 <- emptyR\n  holder1 <- matrix(values(holder), c(rownum,colnum) )\n  \n  #split up \n  for (i in 1:(numFuelsToSplit)){\n    emptyRTemp <-emptyR\n    print(i)\n    toFind <- toDivide$value[i]\n    \n    cellsFound <- which(values(tR1) == toFind)\n    values(emptyRTemp)[cellsFound] <- i #temp var... \n    values(holder2)[cellsFound] <- i \n    \n    eVals <- matrix(values(emptyRTemp), c(rownum,colnum) ) \n    \n    #balance the values of the row and column sum using the equilibrium function to obtian the middle of the connected components\n    #row and col are flipped (probably because of projection?)\n    cols <- colSums(eVals)\n    ret <-equalibrium(arr=cols, tol=max(cols))\n    holder1[which(eVals[,ret]==i), ret]<- i*100 \n    \n    rows <- rowSums(eVals)\n    retr <- equalibrium(arr=rows, tol=max(rows))\n    holder1[retr, which(eVals[retr,]==i)]<- i*100 +1 \n    \n    storage[i,] <- data.frame(colEq=ret, rowEq=retr, step=i*100)# log this? \n  }\n  print(storage) \n\n  values(holder) <-as.vector(holder1)\n  # convert the temporary NA values (0) back to NA \n  values(holder)[which(values(holder) ==0)] <- NA\n  \n  #if tabuList is TRUE then make sure that the cuts are not too close\n  if (tabuList){ holder <- createTabuList(cuts=storage, cutRaster= holder, tabuLength = 10,tabuListPath=tabuListPath)} \n  \n  return(holder)\n}\n\n# reduce the amount of cuts that are stacking next to each other\n# @param cuts - the row and column that make the cuts\n# @param cutRaster - the location of the cuts in the raster where the values corresponds to an ID from cuts \n# @param proximityTol - cuts within this tolerance will be disregarded\n# @param tabuLength - number of years that the tabu list will remember\ncreateTabuList <- function(cuts, cutRaster, proximityTol =10 , tabuLength, tabuListPath=tabuListPath){\n  #get the current timestep to use as id\n  timestep <- as.numeric(readLines( \"lockfile\",n = 1))\n  \n  #read in the past cuts \n  tabuList <- read.csv(tabuListPath, header=T)\n  \n  #throw out cuts that are within tolerance\n  for (i in 1:length(cuts$colEq))\n  {\n    if ( checkTolerance(cuts[i,]$colEq, cuts[i,]$rowEq, tabuList, tol=proximityTol) ) #if cuts are within the tolerance \n    {\n      cutVals <- values(cutRaster)\n      cutVals[ which(cuts[i,]$step== cutVals | cuts[i,]$step == (cutVals+1) )]<- NA\n      values(cutRaster) <- cutVals\n      print(\"removing private cuts ....\" )\n    }\n  }\n  \n  #update tabulist\n  if ( length(tabuList$colEq) < tabuLength)  # if tabu list is not at capacity, then fill it\n  {\n    tabuList <- rbind(tabuList, cbind(cuts, id=rep(timestep,length(cuts$colEq)))) \n  }\n  else { #tabu list is full. replace the oldest id.\n    tabuList <- read.csv(tabuListPath, header = T)\n    minID <- min(tabuList$id)\n    rowsToReplace <- which(minID==tabuList$id)\n    tabuList <- tabuList[-rowsToReplace,]\n    tabuList<- rbind(tabuList,cbind(cuts, id=rep(timestep,length(cuts$colEq))))\n  }\n  \n  #write out updated tabu list \n  write.csv(tabuList, tabuListPath, row.names = F, quote = F)\n  \n  #return updated cutRaster\n  return(cutRaster)\n  \n}\n\ncheckTolerance <- function(c, r, tabuList, tol){\n  \n  if (length(tabuList$colEq) == 0){return(FALSE)} #if the tabuList is empty then there is nothing to check \n  \n  checks <- apply (tabuList,1, function (row){ \n    row<-as.data.frame(t(row)); \n    return( (((row$rowEq-tol)<r) & (r<(row$rowEq +tol))) | (((row$colEq-tol)<c) & (c<(row$colEq +tol))) ) \n  })\n  #print(Reduce(\"|\", checks))\n  return(Reduce(\"|\", checks)) # if there is at least one true value that means we are within the tolerance and we do not want to keep that cut. \n}\n",
    "created" : 1532108175420.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1803405695",
    "id" : "66D5F747",
    "lastKnownWriteTime" : 1532108106,
    "last_content_update" : 1532108106,
    "path" : "C:/Users/hfintern/Desktop/LANDIS_Klamath_REU2018/FindFuelBreaks.R",
    "project_path" : "FindFuelBreaks.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}